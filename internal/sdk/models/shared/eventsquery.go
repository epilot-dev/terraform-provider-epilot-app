// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/epilot-dev/terraform-provider-epilot-app/internal/sdk/internal/utils"
	"time"
)

type GroupBy string

const (
	GroupBySource      GroupBy = "source"
	GroupByComponentID GroupBy = "component_id"
	GroupByEventType   GroupBy = "event_type"
	GroupByHour        GroupBy = "hour"
	GroupByDay         GroupBy = "day"
)

func (e GroupBy) ToPointer() *GroupBy {
	return &e
}
func (e *GroupBy) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "source":
		fallthrough
	case "component_id":
		fallthrough
	case "event_type":
		fallthrough
	case "hour":
		fallthrough
	case "day":
		*e = GroupBy(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GroupBy: %v", v)
	}
}

type EventsQueryMetrics string

const (
	EventsQueryMetricsCount       EventsQueryMetrics = "count"
	EventsQueryMetricsErrorRate   EventsQueryMetrics = "error_rate"
	EventsQueryMetricsUniqueUsers EventsQueryMetrics = "unique_users"
)

func (e EventsQueryMetrics) ToPointer() *EventsQueryMetrics {
	return &e
}
func (e *EventsQueryMetrics) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "count":
		fallthrough
	case "error_rate":
		fallthrough
	case "unique_users":
		*e = EventsQueryMetrics(v)
		return nil
	default:
		return fmt.Errorf("invalid value for EventsQueryMetrics: %v", v)
	}
}

type Aggregation struct {
	// Group results by specified fields
	GroupBy []GroupBy `json:"group_by,omitempty"`
	// Metrics to calculate
	Metrics []EventsQueryMetrics `json:"metrics,omitempty"`
}

func (o *Aggregation) GetGroupBy() []GroupBy {
	if o == nil {
		return nil
	}
	return o.GroupBy
}

func (o *Aggregation) GetMetrics() []EventsQueryMetrics {
	if o == nil {
		return nil
	}
	return o.Metrics
}

type EventsQueryEventType string

const (
	EventsQueryEventTypeError   EventsQueryEventType = "ERROR"
	EventsQueryEventTypeWarning EventsQueryEventType = "WARNING"
	EventsQueryEventTypeInfo    EventsQueryEventType = "INFO"
)

func (e EventsQueryEventType) ToPointer() *EventsQueryEventType {
	return &e
}
func (e *EventsQueryEventType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ERROR":
		fallthrough
	case "WARNING":
		fallthrough
	case "INFO":
		*e = EventsQueryEventType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for EventsQueryEventType: %v", v)
	}
}

type Filters struct {
	// Filter by specific component IDs
	ComponentID []string `json:"component_id,omitempty"`
	// Filter by correlation ID for tracing
	CorrelationID *string `json:"correlation_id,omitempty"`
	// Filter by event types
	EventType []EventsQueryEventType `json:"event_type,omitempty"`
	// Filter by component types
	Source []ComponentType `json:"source,omitempty"`
}

func (o *Filters) GetComponentID() []string {
	if o == nil {
		return nil
	}
	return o.ComponentID
}

func (o *Filters) GetCorrelationID() *string {
	if o == nil {
		return nil
	}
	return o.CorrelationID
}

func (o *Filters) GetEventType() []EventsQueryEventType {
	if o == nil {
		return nil
	}
	return o.EventType
}

func (o *Filters) GetSource() []ComponentType {
	if o == nil {
		return nil
	}
	return o.Source
}

type Pagination struct {
	Page     *int64 `default:"1" json:"page"`
	PageSize *int64 `default:"100" json:"page_size"`
}

func (p Pagination) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *Pagination) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *Pagination) GetPage() *int64 {
	if o == nil {
		return nil
	}
	return o.Page
}

func (o *Pagination) GetPageSize() *int64 {
	if o == nil {
		return nil
	}
	return o.PageSize
}

type Field string

const (
	FieldTimestamp   Field = "timestamp"
	FieldEventType   Field = "event_type"
	FieldComponentID Field = "component_id"
)

func (e Field) ToPointer() *Field {
	return &e
}
func (e *Field) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "timestamp":
		fallthrough
	case "event_type":
		fallthrough
	case "component_id":
		*e = Field(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Field: %v", v)
	}
}

type Order string

const (
	OrderAsc  Order = "asc"
	OrderDesc Order = "desc"
)

func (e Order) ToPointer() *Order {
	return &e
}
func (e *Order) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "asc":
		fallthrough
	case "desc":
		*e = Order(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Order: %v", v)
	}
}

type Sort struct {
	Field *Field `default:"timestamp" json:"field"`
	Order *Order `default:"desc" json:"order"`
}

func (s Sort) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *Sort) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *Sort) GetField() *Field {
	if o == nil {
		return nil
	}
	return o.Field
}

func (o *Sort) GetOrder() *Order {
	if o == nil {
		return nil
	}
	return o.Order
}

// Preset - Predefined time range (alternative to start/end)
type Preset string

const (
	PresetOneh        Preset = "1h"
	PresetSixh        Preset = "6h"
	PresetTwentyFourh Preset = "24h"
	PresetSevend      Preset = "7d"
	PresetThirtyd     Preset = "30d"
)

func (e Preset) ToPointer() *Preset {
	return &e
}
func (e *Preset) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "1h":
		fallthrough
	case "6h":
		fallthrough
	case "24h":
		fallthrough
	case "7d":
		fallthrough
	case "30d":
		*e = Preset(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Preset: %v", v)
	}
}

// TimeRange - Either use preset OR start+end
type TimeRange struct {
	// End time (ISO 8601)
	End *time.Time `json:"end,omitempty"`
	// Predefined time range (alternative to start/end)
	Preset *Preset `json:"preset,omitempty"`
	// Start time (ISO 8601)
	Start *time.Time `json:"start,omitempty"`
}

func (t TimeRange) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TimeRange) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *TimeRange) GetEnd() *time.Time {
	if o == nil {
		return nil
	}
	return o.End
}

func (o *TimeRange) GetPreset() *Preset {
	if o == nil {
		return nil
	}
	return o.Preset
}

func (o *TimeRange) GetStart() *time.Time {
	if o == nil {
		return nil
	}
	return o.Start
}

type EventsQuery struct {
	Aggregation *Aggregation `json:"aggregation,omitempty"`
	Filters     *Filters     `json:"filters,omitempty"`
	Pagination  *Pagination  `json:"pagination,omitempty"`
	Sort        *Sort        `json:"sort,omitempty"`
	// Either use preset OR start+end
	TimeRange *TimeRange `json:"time_range,omitempty"`
}

func (o *EventsQuery) GetAggregation() *Aggregation {
	if o == nil {
		return nil
	}
	return o.Aggregation
}

func (o *EventsQuery) GetFilters() *Filters {
	if o == nil {
		return nil
	}
	return o.Filters
}

func (o *EventsQuery) GetPagination() *Pagination {
	if o == nil {
		return nil
	}
	return o.Pagination
}

func (o *EventsQuery) GetSort() *Sort {
	if o == nil {
		return nil
	}
	return o.Sort
}

func (o *EventsQuery) GetTimeRange() *TimeRange {
	if o == nil {
		return nil
	}
	return o.TimeRange
}
