// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/epilot-dev/terraform-provider-epilot-app/internal/sdk/internal/utils"
)

// SchemasEnumArgDescription - Description of what this component arg does
type SchemasEnumArgDescription struct {
	// German translation
	De string `json:"de"`
	// English translation
	En *string `json:"en,omitempty"`
}

func (o *SchemasEnumArgDescription) GetDe() string {
	if o == nil {
		return ""
	}
	return o.De
}

func (o *SchemasEnumArgDescription) GetEn() *string {
	if o == nil {
		return nil
	}
	return o.En
}

// SchemasLabel - Human-readable label for the component arg
type SchemasLabel struct {
	// German translation
	De string `json:"de"`
	// English translation
	En *string `json:"en,omitempty"`
}

func (o *SchemasLabel) GetDe() string {
	if o == nil {
		return ""
	}
	return o.De
}

func (o *SchemasLabel) GetEn() *string {
	if o == nil {
		return nil
	}
	return o.En
}

// SchemasEnumArgLabel - Display label for the option
type SchemasEnumArgLabel struct {
	// German translation
	De string `json:"de"`
	// English translation
	En *string `json:"en,omitempty"`
}

func (o *SchemasEnumArgLabel) GetDe() string {
	if o == nil {
		return ""
	}
	return o.De
}

func (o *SchemasEnumArgLabel) GetEn() *string {
	if o == nil {
		return nil
	}
	return o.En
}

type SchemasOptions struct {
	// Unique identifier for the option
	ID    string              `json:"id"`
	Label SchemasEnumArgLabel `json:"label"`
}

func (o *SchemasOptions) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *SchemasOptions) GetLabel() SchemasEnumArgLabel {
	if o == nil {
		return SchemasEnumArgLabel{}
	}
	return o.Label
}

type SchemasType string

const (
	SchemasTypeText    SchemasType = "text"
	SchemasTypeBoolean SchemasType = "boolean"
	SchemasTypeEnum    SchemasType = "enum"
)

func (e SchemasType) ToPointer() *SchemasType {
	return &e
}
func (e *SchemasType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "text":
		fallthrough
	case "boolean":
		fallthrough
	case "enum":
		*e = SchemasType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SchemasType: %v", v)
	}
}

type EnumArgSchemas struct {
	Description *SchemasEnumArgDescription `json:"description,omitempty"`
	// If true, allows selection of multiple values
	IsMulti *bool `default:"false" json:"isMulti"`
	// Unique identifier for this component arg
	Key   string       `json:"key"`
	Label SchemasLabel `json:"label"`
	// List of options for enum type
	Options []SchemasOptions `json:"options"`
	// Flag to indicate if this option is required
	Required *bool       `default:"false" json:"required"`
	Type     SchemasType `json:"type"`
}

func (e EnumArgSchemas) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *EnumArgSchemas) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *EnumArgSchemas) GetDescription() *SchemasEnumArgDescription {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *EnumArgSchemas) GetIsMulti() *bool {
	if o == nil {
		return nil
	}
	return o.IsMulti
}

func (o *EnumArgSchemas) GetKey() string {
	if o == nil {
		return ""
	}
	return o.Key
}

func (o *EnumArgSchemas) GetLabel() SchemasLabel {
	if o == nil {
		return SchemasLabel{}
	}
	return o.Label
}

func (o *EnumArgSchemas) GetOptions() []SchemasOptions {
	if o == nil {
		return []SchemasOptions{}
	}
	return o.Options
}

func (o *EnumArgSchemas) GetRequired() *bool {
	if o == nil {
		return nil
	}
	return o.Required
}

func (o *EnumArgSchemas) GetType() SchemasType {
	if o == nil {
		return SchemasType("")
	}
	return o.Type
}

// Description of what this component arg does
type Description struct {
	// German translation
	De string `json:"de"`
	// English translation
	En *string `json:"en,omitempty"`
}

func (o *Description) GetDe() string {
	if o == nil {
		return ""
	}
	return o.De
}

func (o *Description) GetEn() *string {
	if o == nil {
		return nil
	}
	return o.En
}

// Label - Human-readable label for the component arg
type Label struct {
	// German translation
	De string `json:"de"`
	// English translation
	En *string `json:"en,omitempty"`
}

func (o *Label) GetDe() string {
	if o == nil {
		return ""
	}
	return o.De
}

func (o *Label) GetEn() *string {
	if o == nil {
		return nil
	}
	return o.En
}

type Type string

const (
	TypeText    Type = "text"
	TypeBoolean Type = "boolean"
	TypeEnum    Type = "enum"
)

func (e Type) ToPointer() *Type {
	return &e
}
func (e *Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "text":
		fallthrough
	case "boolean":
		fallthrough
	case "enum":
		*e = Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Type: %v", v)
	}
}

type Schemas struct {
	Description *Description `json:"description,omitempty"`
	// Unique identifier for this component arg
	Key   string `json:"key"`
	Label Label  `json:"label"`
	// Flag to indicate if this option is required
	Required *bool `default:"false" json:"required"`
	Type     Type  `json:"type"`
}

func (s Schemas) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *Schemas) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *Schemas) GetDescription() *Description {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *Schemas) GetKey() string {
	if o == nil {
		return ""
	}
	return o.Key
}

func (o *Schemas) GetLabel() Label {
	if o == nil {
		return Label{}
	}
	return o.Label
}

func (o *Schemas) GetRequired() *bool {
	if o == nil {
		return nil
	}
	return o.Required
}

func (o *Schemas) GetType() Type {
	if o == nil {
		return Type("")
	}
	return o.Type
}

// SchemasTextArgDescription - Description of what this component arg does
type SchemasTextArgDescription struct {
	// German translation
	De string `json:"de"`
	// English translation
	En *string `json:"en,omitempty"`
}

func (o *SchemasTextArgDescription) GetDe() string {
	if o == nil {
		return ""
	}
	return o.De
}

func (o *SchemasTextArgDescription) GetEn() *string {
	if o == nil {
		return nil
	}
	return o.En
}

// SchemasTextArgLabel - Human-readable label for the component arg
type SchemasTextArgLabel struct {
	// German translation
	De string `json:"de"`
	// English translation
	En *string `json:"en,omitempty"`
}

func (o *SchemasTextArgLabel) GetDe() string {
	if o == nil {
		return ""
	}
	return o.De
}

func (o *SchemasTextArgLabel) GetEn() *string {
	if o == nil {
		return nil
	}
	return o.En
}

type SchemasTextArgType string

const (
	SchemasTextArgTypeText    SchemasTextArgType = "text"
	SchemasTextArgTypeBoolean SchemasTextArgType = "boolean"
	SchemasTextArgTypeEnum    SchemasTextArgType = "enum"
)

func (e SchemasTextArgType) ToPointer() *SchemasTextArgType {
	return &e
}
func (e *SchemasTextArgType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "text":
		fallthrough
	case "boolean":
		fallthrough
	case "enum":
		*e = SchemasTextArgType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SchemasTextArgType: %v", v)
	}
}

type TextArgSchemas struct {
	Description *SchemasTextArgDescription `json:"description,omitempty"`
	// Unique identifier for this component arg
	Key   string              `json:"key"`
	Label SchemasTextArgLabel `json:"label"`
	// Flag to indicate if this option is required
	Required *bool              `default:"false" json:"required"`
	Type     SchemasTextArgType `json:"type"`
}

func (t TextArgSchemas) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TextArgSchemas) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *TextArgSchemas) GetDescription() *SchemasTextArgDescription {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *TextArgSchemas) GetKey() string {
	if o == nil {
		return ""
	}
	return o.Key
}

func (o *TextArgSchemas) GetLabel() SchemasTextArgLabel {
	if o == nil {
		return SchemasTextArgLabel{}
	}
	return o.Label
}

func (o *TextArgSchemas) GetRequired() *bool {
	if o == nil {
		return nil
	}
	return o.Required
}

func (o *TextArgSchemas) GetType() SchemasTextArgType {
	if o == nil {
		return SchemasTextArgType("")
	}
	return o.Type
}

type JourneyBlockComponentArgsType string

const (
	JourneyBlockComponentArgsTypeBoolean JourneyBlockComponentArgsType = "boolean"
	JourneyBlockComponentArgsTypeEnum    JourneyBlockComponentArgsType = "enum"
	JourneyBlockComponentArgsTypeText    JourneyBlockComponentArgsType = "text"
)

type JourneyBlockComponentArgs struct {
	TextArgSchemas *TextArgSchemas `queryParam:"inline"`
	Schemas        *Schemas        `queryParam:"inline"`
	EnumArgSchemas *EnumArgSchemas `queryParam:"inline"`

	Type JourneyBlockComponentArgsType
}

func CreateJourneyBlockComponentArgsBoolean(boolean Schemas) JourneyBlockComponentArgs {
	typ := JourneyBlockComponentArgsTypeBoolean

	typStr := Type(typ)
	boolean.Type = typStr

	return JourneyBlockComponentArgs{
		Schemas: &boolean,
		Type:    typ,
	}
}

func CreateJourneyBlockComponentArgsEnum(enum EnumArgSchemas) JourneyBlockComponentArgs {
	typ := JourneyBlockComponentArgsTypeEnum

	typStr := SchemasType(typ)
	enum.Type = typStr

	return JourneyBlockComponentArgs{
		EnumArgSchemas: &enum,
		Type:           typ,
	}
}

func CreateJourneyBlockComponentArgsText(text TextArgSchemas) JourneyBlockComponentArgs {
	typ := JourneyBlockComponentArgsTypeText

	typStr := SchemasTextArgType(typ)
	text.Type = typStr

	return JourneyBlockComponentArgs{
		TextArgSchemas: &text,
		Type:           typ,
	}
}

func (u *JourneyBlockComponentArgs) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "boolean":
		schemas := new(Schemas)
		if err := utils.UnmarshalJSON(data, &schemas, "", true, false); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == boolean) type Schemas within JourneyBlockComponentArgs: %w", string(data), err)
		}

		u.Schemas = schemas
		u.Type = JourneyBlockComponentArgsTypeBoolean
		return nil
	case "enum":
		enumArgSchemas := new(EnumArgSchemas)
		if err := utils.UnmarshalJSON(data, &enumArgSchemas, "", true, false); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == enum) type EnumArgSchemas within JourneyBlockComponentArgs: %w", string(data), err)
		}

		u.EnumArgSchemas = enumArgSchemas
		u.Type = JourneyBlockComponentArgsTypeEnum
		return nil
	case "text":
		textArgSchemas := new(TextArgSchemas)
		if err := utils.UnmarshalJSON(data, &textArgSchemas, "", true, false); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == text) type TextArgSchemas within JourneyBlockComponentArgs: %w", string(data), err)
		}

		u.TextArgSchemas = textArgSchemas
		u.Type = JourneyBlockComponentArgsTypeText
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for JourneyBlockComponentArgs", string(data))
}

func (u JourneyBlockComponentArgs) MarshalJSON() ([]byte, error) {
	if u.TextArgSchemas != nil {
		return utils.MarshalJSON(u.TextArgSchemas, "", true)
	}

	if u.Schemas != nil {
		return utils.MarshalJSON(u.Schemas, "", true)
	}

	if u.EnumArgSchemas != nil {
		return utils.MarshalJSON(u.EnumArgSchemas, "", true)
	}

	return nil, errors.New("could not marshal union type JourneyBlockComponentArgs: all fields are null")
}
